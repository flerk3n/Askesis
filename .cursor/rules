Askesis Web App Technical Documentation
Tagline
Askesis: Enlighten Your Mind Through Socratic AI Inquiry – a concise slogan emphasizing the platform’s use of guided questioning to foster learning. (Other possible taglines might include “Askesis: Empowering Learning through Socratic Questioning.”)
UI Structure
Landing Page
Layout: A dark-themed fullscreen landing page (background color #0f0e17). At the very top-left, display the Askesis logo. At the top-right, place an elevated “Start Learning” button (bright #ff8906) with white text, and an “About” button immediately to its left.
Center Content: Vertically and horizontally centered on the page, include three large buttons: “Replicas”, “Pricing”, and “FAQ”. Each should use the orange button color (#ff8906) with white text (#fffffe) and a subtle hover effect.
Background Animation: Apply a very minimal CSS animation in the dark palette (e.g. a slow-moving gradient or faint floating shapes) to give the page life without distraction. For example, an animated gradient shift using CSS @keyframes or a canvas of drifting dots can be used as a subtle effect.
Replicas Page
Content: Present three card components (in a row or responsive grid), one for each AI teacher (Philosophy, Literature, History). Each card includes: a photo or illustrative portrait of the teacher, their name (e.g. “Dr. Evelyn Harper”), their subject, and a brief bio. Use legible text (Poppins) for the bio and cursive (Great Vibes) for the subject label.
Styling: Cards should stand out on the dark background with a lighter accent border or shadow. Each card’s heading (teacher’s name and subject) is in white (#fffffe), and paragraph text in muted gray (#a7a9be).
Pricing Page
Tiers: Display three columns or cards for Free, Starter, and Professional plans. Each should list example features such as “Talk Time Per Month,” “AI Response Priority,” and “Sessions Per Month.” For example: Free tier (e.g. 10 min/month, standard speed, 5 sessions), Starter tier (100 min, faster, 50 sessions), Professional tier (unlimited, high priority, unlimited).
Design: Use the same dark background with white headings and gray text. Highlight the primary tier (Starter) with a slightly different accent or a “Most Popular” badge. Ensure buttons (e.g. “Select Plan”) use the orange color.
Contact Page
Form: Provide a simple email contact form with fields for name, email, and message. The form can be wired to a mailto: link or handled by a serverless function (e.g. using Next.js API routes or services like Formspree). Include a “Submit” button in the theme’s orange color.
Layout: The form fields and button should be in a centered column on the dark background, with labels in white and input placeholders in light gray.
About Page
Content: This can be part of the landing page (e.g. an “About” section that scrolls into view). Provide detailed explanations of Askesis’s philosophy and purpose. For example, describe how Askesis uses the Socratic method, the inspiration behind AI teachers, etc. Use headings in white and body text in #a7a9be. Include any relevant images or illustrations at top (e.g. an abstract learning graphic).
Login Page
Layout: Split the page into two halves. On the left, display an illustrative image or abstract graphic related to learning/knowledge. On the right, show the login/signup form.
Auth Form: Include fields for Email and Password (for email/password auth) and a “Sign in with Google” button. Use Firebase Auth (see below) to handle these. The Google button should include the Google icon and text. Ensure form inputs and buttons follow the theme (inputs with subtle borders, submit button in orange).
Typography: Use Poppins for form labels and Great Vibes for any stylized headings (e.g. above the form “Welcome to Askesis”).
Subject Selection Page
Prompt: After login, ask the user: “What do you want to learn today?” – styled in the Poppins font, large and centered.
Options: Below this question, list the three subjects: Philosophy, Literature, History. Each subject name is displayed in Great Vibes cursive font, colored orange (#ff8906). These can be buttons or cards that the user clicks to choose. Each subject is accompanied by a short descriptor if needed.
Chat Interface (Post-Login)
Flow: Once a subject is selected, navigate to a chat page for that subject. Display a chat window where the conversation occurs. The header of this page should show the teacher’s name and maybe a small avatar (e.g. “Dr. Evelyn Harper – Philosophy” in white).
Chat Window: Show past messages (if any), alternating between user queries (right-aligned) and teacher responses (left-aligned). Use the appropriate text colors and timestamps. At the bottom, provide an input box (Poppins, light gray background) for the user to type a question, and a send button (orange).
Socratic Voice: Design the interface to encourage asking questions. The teacher’s responses should appear after a brief moment (you can use a loading indicator while waiting for API response).
Styling & Theming
Color Palette: Use the specified theme colors: background #0f0e17, headlines/text #fffffe, paragraph text #a7a9be, primary button #ff8906 with button text #fffffe. (This matches a standard dark-mode palette
github.com
.)
Fonts: Load Poppins for all interface text (body, buttons, labels) and Great Vibes for any cursive headings (like subject titles). Ensure fallbacks are included.
Animations: For minimal background animation, consider a CSS gradient animation or floating particle effect in subtle orange/gray tones. For example, a slow-moving linear gradient shift or small floating dots (using CSS animation and opacity changes) can add interest without detracting from content.
Authentication & User Management
Firebase Authentication Setup
Firebase Config: Add Firebase to the Next.js project (via firebase/app and firebase/auth). Include your Firebase project’s config (apiKey, authDomain, etc.) in an environment file or a secure location.
Enable Providers: In the Firebase console Auth section, enable Email/Password and Google sign-in methods
firebase.google.com
.
Google Sign-In: In code, initialize the Google provider and handle the popup flow. For example:
js
Copy
Edit
import { getAuth, GoogleAuthProvider, signInWithPopup } from "firebase/auth";
const auth = getAuth();
const provider = new GoogleAuthProvider();  // :contentReference[oaicite:2]{index=2}
// On button click:
signInWithPopup(auth, provider).then((result) => { /* handle user */ });
Email/Password: Also provide a form to register/sign in with email and password using Firebase’s createUserWithEmailAndPassword and signInWithEmailAndPassword. Ensure the UI has the corresponding inputs.
Linking with Sensay User
After Firebase successfully authenticates a user, use the Firebase UID (or their email) as the unique user ID in Sensay. To integrate with Sensay:
Sensay API Keys: Store your Sensay organization secret key as an environment variable (e.g. SENSAY_API_KEY). All Sensay requests must include X-ORGANIZATION-SECRET: $API_KEY in headers
docs.sensay.io
. When performing user-specific requests (like sending/receiving chat), also include X-USER-ID: {userId}
docs.sensay.io
.
User Creation: On first login, check if the user exists in Sensay. For example, call GET /v1/users?id={uid} (using the Sensay SDK or fetch). If it returns 404, create the user with a POST /v1/users request, including their name/email/ID in the JSON body
docs.sensay.io
. For instance:
bash
Copy
Edit
curl -X POST https://api.sensay.io/v1/users \
  -H "X-ORGANIZATION-SECRET: $API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"name":"Alice Example","email":"alice@example.com","id":"<USER_ID>"}'
This registers the user in Sensay with the same ID. (The tutorial code does a similar check-and-create flow
docs.sensay.io
.)
Error Handling: Ensure to handle “User not found” errors by creating the user, and include the organization key in headers for these admin-level calls
docs.sensay.io
docs.sensay.io
.
Sensay Integration (Backend)
Setting Up Sensay Client/SDK
OpenAPI SDK: Sensay provides an OpenAPI spec (downloadable from their docs). You can generate a client SDK (e.g. TypeScript) with a tool like openapi-typescript-codegen. The example tutorial includes a script (npm run generate-sdk) that fetches the latest spec and regenerates the client code
docs.sensay.io
. This ensures all API endpoints are available in a type-safe way.
Initialization: Initialize two Sensay client instances: one for organization-level actions (admin) and one for user-level (scoped to the logged-in user). For example (using the generated client):
js
Copy
Edit
const organizationClient = new Client({
  BASE: 'https://api.sensay.io',
  HEADERS: { 'X-ORGANIZATION-SECRET': SENSAY_API_KEY }
});
const userClient = new Client({
  BASE: 'https://api.sensay.io',
  HEADERS: {
    'X-ORGANIZATION-SECRET': SENSAY_API_KEY,
    'X-USER-ID': firebaseUserId
  }
});
This matches the pattern in the Sensay tutorial
docs.sensay.io
. All further calls to userClient will automatically include the correct headers.
Replica (AI Teacher) Setup
Initialize Replicas: For each subject (Philosophy, Literature, History), create a corresponding Sensay replica. Use the POST /v1/replicas endpoint (createReplicaPost in the SDK). The payload should include fields such as name, shortDescription, greeting, type: "character", ownerID (your Sensay user ID or admin user), and LLM configuration. For example:
json
Copy
Edit
{
  "name": "Dr. Evelyn Harper",
  "shortDescription": "A thoughtful Philosophy professor known for probing questions.",
  "greeting": "Welcome! What philosophical question intrigues you today?",
  "type": "character",
  "ownerID": "<USER_ID>",
  "private": false,
  "slug": "dr-evelyn-harper",
  "tags": ["philosophy", "thinker"],
  "llm": {
    "provider": "openai",
    "model": "gpt-4o",
    "memoryMode": "rag-search",
    "systemMessage": "You are a Socratic philosophy tutor. Ask probing questions and encourage thoughtful responses."
  }
}
(This structure is similar to the example in the Sensay docs
docs.sensay.io
.) Submit this with X-ORGANIZATION-SECRET and content-type headers. The response will include a uuid for the new replica.
Idempotent Setup: On app startup, you can call GET /v1/replicas (listReplicasGet) to see if these replicas already exist. If not, create them. The tutorial demonstrates listing replicas and conditionally creating one if none exist
docs.sensay.io
. Use a check like if (replicas.items.length === 0) { createReplicaPost(...) }.
Replica Details: Give each replica a personality via the systemMessage (e.g., Socratic tone), an appropriate greeting, and an image URL (profileImage) if desired. Mark private: false so all users in your organization can chat with them.
Training AI Replicas
To make each replica knowledgeable, use the Sensay Training API to add educational content:
Create Knowledge Base Entry: First send a POST to /v1/replicas/{replicaUUID}/training with an empty JSON ({}) to get a new knowledgeBaseID
docs.sensay.io
.
Add Text Content: Next, send a PUT to /v1/replicas/{replicaUUID}/training/{knowledgeBaseID} with JSON containing your text under "rawText". For example:
bash
Copy
Edit
curl -X PUT https://api.sensay.io/v1/replicas/<REPLICA_UUID>/training/<KB_ID> \
  -H "X-ORGANIZATION-SECRET: $API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"rawText":"This is Socratic dialogue content or your subject-specific corpus..."}'
After sending, Sensay processes and incorporates this text into the replica’s knowledge
docs.sensay.io
docs.sensay.io
.
Upload Documents (Optional): For large materials (PDF/text files), use the signed-URL flow: GET /v1/replicas/{id}/training/files/upload?filename=YourFile.pdf to receive a signedURL and knowledgeBaseID
docs.sensay.io
. Then PUT your file binary to that URL. The system will extract and process the text automatically.
Manage Entries: You can list all entries with GET /v1/replicas/{id}/training or fetch one by ID. When ready, each replica will use this added knowledge for answering related questions.
Chat Functionality (Real-time Chat)
Sending Messages: When the user types a question, call the Sensay chat completion endpoint: POST /v1/replicas/{replicaUUID}/chat/completions. In the SDK this is userClient.replicaChatCompletions.createChatCompletionPost({replicaUuid, content: userMessage}). Ensure the headers include both X-ORGANIZATION-SECRET and X-USER-ID. For example, a raw request might look like
docs.sensay.io
:
bash
Copy
Edit
curl --request POST 'https://api.sensay.io/v1/replicas/<REPLICA_UUID>/chat/completions' \
     --header "X-ORGANIZATION-SECRET: $API_KEY" \
     --header "X-USER-ID: <USER_ID>" \
     --header "Content-Type: application/json" \
     --data '{"content":"What does Socrates mean by knowledge?","skip_chat_history":false,"source":"web"}'
The response will be JSON with fields like "content": "..." (the AI’s answer) and "success": true. Process this response and display the content as the teacher’s reply. If using JSON streaming, set Accept: application/json; Sensay also supports text/event-stream for server-sent events (SSE) if you want token-by-token streaming, but JSON is simplest for a chat UI.
Chat History: Each completion call automatically logs the message pair into history. You can retrieve the conversation history with GET /v1/replicas/{replicaUUID}/chat/history/web
docs.sensay.io
. This returns an array of messages (with roles “user” or “assistant”), timestamps, etc. You can use this to load past messages in the chat window when the user revisits a subject or refreshes.
Context and Memory: By default, Sensay includes the previous dialogue for context. The "skip_chat_history":false flag ensures the AI can reference earlier questions. You may toggle this if you want independent sessions.
Implementation: In Node/Next.js, you might implement an API route (e.g. /api/chat) that takes the user’s question from the frontend, calls the Sensay API as above, and returns the AI response to the client. Use the official SDK or fetch/axios with the headers specified. For instance, using the SDK:
js
Copy
Edit
const resp = await userClient.replicaChatCompletions.createChatCompletionPost({
  replicaUuid: selectedReplicaUuid,
  content: userQuestion
});
if (resp.success) {
  // resp.content contains AI reply
}
(See the tutorial snippet for sending messages
docs.sensay.io
.)
Deployment
Once built, deploy the Next.js frontend and Node backend to a hosting service (e.g. Vercel, Netlify, or a custom server). The Sensay tutorial recommends deploying to platforms like Vercel or Netlify
docs.sensay.io
. Ensure your production environment variables (NEXT_PUBLIC_SENSAY_API_KEY, Firebase keys, etc.) are set.